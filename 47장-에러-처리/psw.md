# 47장 에러 처리

# 47.1 에러 처리의 필요성

에러 처리는 코딩 작성에 있어서 필수 불가결한 절차이다. 에러를 방치하면 프로그램이 강제 종료된다. 에러 처리를 하여 적절히 대응하면 에러가 발생해도 계속해서 실행 할 수 있다.

직접적으로 에러를 발생 시키진 않는 예외 상황이 있을 수 있다. 하지만 이러한 예외는 에러로 이어질 가능성이 크니 적절한 대응이 필수이다.

# 47.2 try…catch…finally 문

try…catch…finally 문은 세 개의 코드 블럭으로 이루어진 문이다.

가장 먼저 try코드 블럭이 실행되고 실행 중에 에러가 발생하면 err변수에 할당되어 catch 코드블럭이 실행된다. 마지막으로 finally문은 에러 발생에 관계없이 마지막에 한 번 실행된다. 이런 방법으로 에러를 처리하면 프로그램이 종료 되지 않는다.

# 47.3 Error 객체

Error 생성자 함수는 에러 객체를 생성한다. 생성자 함수에 에러 메시지를 인수로 전달 할 수 있다. Error 객체에는 인수로 전달받은 message 프로퍼티와 에러를 발생 시킨 콜스택의 호출 정보를 나타내는 문자열인 stack 프로퍼티가 있다.

Error.prototype을 상속받는 에러 객체는 7개의 에러 객체가 있다.

| 생성자 함수   | 인스턴스                                                                |
| ------------- | ----------------------------------------------------------------------- |
| Error         | 일반적인 에러 객체                                                      |
| SyntaxError   | 문법 에러                                                               |
| RefernceError | 참조 에러                                                               |
| TypeError     | 피연산자 혹은 인수의 데이터 타입이 유효하지 않는 에러                   |
| RangeError    | 숫자 값의 허용 범위를 벗어난 에러                                       |
| URIError      | encodeURI, decodeURI 함수에 부적절한 인수가 전달 되었음을 의미하는 에러 |
| EvalError     | eval 함수에서 발생하는 에러                                             |

# 47.4 throw문

에러 객체의 생성은 에러 발생과는 엄연히 다르다. 에러 객체를 생성한다고 에러가 발생하진 않는다.

에러를 발생 시키려면 try문 내에서 throw문으로 에러 객체를 던지면 된다.

# 47.5 에러의 전파

앞서 알아본 대로 에러는 호출자 방향으로 전파된다.

만일 throw된 에러가 캐치되지 않는다면 프로그램이 강제 종료된다. throw를 사용하여 에러를 적절히 대응하면 코드의 실행을 복구 할 수 있다.

프로미스 후속 처리 메서드의 콜백 함수나 setTimeout함수와 같은 비동기 함수들은 호출자가 없다. 비동기 함수는 태스크 큐나 마이크로태스크 큐에 일시 저장되었다가 콜스택이 비면 푸쉬되어 실행한다. 이때 푸시된 콜백 함수의 실행 컨택스트는 콜 스택의 최하단에 존재하게 되어 에러를 전파할 호출자가 존재하지 않는다.
